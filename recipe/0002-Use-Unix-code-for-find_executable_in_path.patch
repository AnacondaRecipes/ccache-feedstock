From 8b0c861018a4cc724e9927f73dff9c42888aba08 Mon Sep 17 00:00:00 2001
From: Ray Donnelly <mingw.android@gmail.com>
Date: Wed, 18 Mar 2020 01:09:37 +0000
Subject: [PATCH 2/2] Use Unix code for find_executable_in_path

We must also search for the executable name without any .exe suffix when comparing
it with MYNAME ("ccache")
---
 src/execute.cpp | 61 +++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 51 insertions(+), 10 deletions(-)

diff --git a/src/execute.cpp b/src/execute.cpp
index 7ab4c0d..a720607 100644
--- a/src/execute.cpp
+++ b/src/execute.cpp
@@ -322,6 +322,21 @@ find_executable(const char* name, const char* exclude_name)
   return find_executable_in_path(name, exclude_name, path);
 }
 
+#if defined(_WIN32)
+int
+strrindex(char *fullstring ,char *substring)
+{
+    int i, j, k, res = -1;
+
+    for (i = 0; fullstring[i]; ++i) {
+      for (j = i, k = 0 ; substring[k] && fullstring[j] == substring[k]; ++j, ++k) ;
+        if (k > 0 && !substring[k])
+            res = i;
+    }
+    return res;
+}
+#endif
+
 static char*
 find_executable_in_path(const char* name,
                         const char* exclude_name,
@@ -335,18 +350,44 @@ find_executable_in_path(const char* name,
   for (char* tok = strtok_r(path_buf, PATH_DELIM, &saveptr); tok;
        tok = strtok_r(NULL, PATH_DELIM, &saveptr)) {
 #ifdef _WIN32
-    char namebuf[MAX_PATH];
-    int ret = SearchPath(tok, name, NULL, sizeof(namebuf), namebuf, NULL);
-    if (!ret) {
-      char* exename = format("%s.exe", name);
-      ret = SearchPath(tok, exename, NULL, sizeof(namebuf), namebuf, NULL);
-      free(exename);
-    }
-    (void)exclude_name;
-    if (ret) {
+    char* fname = format("%s\\%s", tok, name);
+    auto st1 = Stat::lstat(fname);
+    auto st2 = Stat::stat(fname);
+#if 0
+    printf("st1 (%s): %s\n", fname, st1 ? "true" : "false");
+    printf("st2 (%s): %s\n", fname, st2 ? "true" : "false");
+    printf("st2.is_regular(): %s\n", st2.is_regular() ? "true" : "false");
+    printf("access(fname, X_OK): %d\n", access(fname, X_OK));
+    printf("st1.is_symlink(): %s\n", st1.is_symlink() ? "true" : "false");
+    char* buf2 = x_realpath(fname);
+    printf("x_realpath(fname): %s\n", buf2);
+#endif
+    // Look for a normal executable file.
+    if (st1 && st2 && st2.is_regular() && access(fname, X_OK) == 0) {
+      char* buf = x_realpath(fname);
+      // if (st1.is_symlink()) { .. is_symlink always returns false, but x_realpath is still useful */
+      if (buf) {
+        if (buf) {
+          int stridx = strrindex(buf, ".exe");
+          int length = strlen(buf);
+          if (stridx == strlen(buf) - 4) {
+            buf[stridx] = '\0';
+          }
+          string_view p = Util::base_name(buf);
+          if (p == exclude_name) {
+            // It's a link to "ccache"!
+            free(buf);
+            continue;
+          }
+          free(buf);
+        }
+      }
+
+      // Found it!
       free(path_buf);
-      return x_strdup(namebuf);
+      return fname;
     }
+    free(fname);
 #else
     char* fname = format("%s/%s", tok, name);
     auto st1 = Stat::lstat(fname);
-- 
2.24.1

